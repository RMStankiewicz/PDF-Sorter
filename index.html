<!DOCTYPE html>
<html lang="pl" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sortowanie Dwustronnych PDF</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Google Font - Rajdhani for futuristic feel -->
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- pdf-lib CDN for PDF manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Favicon / Logo for the browser tab -->
    <link rel="icon" href="https://yt3.ggpht.com/ngn-9Dc6-sRhEOjNglyYu3M_xcXEjm8a569VvH8ZxHHQ1gjZ_KacvIXPyz41zkYLAtVxNIR4pyA=s600-c-k-c0x00ffffff-no-rj-rp-mo" type="image/png">
    <style>
        /* Base styles for dark mode */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .dark body {
            background-color: #0d1117; /* Dark background */
            color: #c9d1d9; /* Light text */
        }

        .dark .bg-white {
            background-color: #161b22; /* Slightly lighter dark for card */
            border: 1px solid #30363d;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .dark h1, .dark h2, .dark label {
            color: #e6edf3;
        }

        .dark p {
            color: #a7adba;
        }

        .dark .border-gray-200 {
            border-color: #30363d;
        }

        .dark .border-gray-300 {
            border-color: #30363d;
        }

        .dark .file-input-wrapper label {
            background-color: #004d99; /* Darker blue for dark mode */
            color: #e6edf3;
        }
        .dark .file-input-wrapper label:hover {
            background-color: #005cb3;
        }

        .dark .drop-zone {
            background-color: #0d1117; /* Darker background for drop zone */
            border-color: #444c56;
        }
        .dark .drop-zone.drag-over {
            border-color: #58a6ff !important;
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.5);
        }
        .dark .drop-zone p {
            color: #8b949e;
        }
        .dark .drop-zone span {
            color: #8b949e;
        }


        /* Styles for light mode (overrides dark mode) */
        .light body {
            background-color: #f0f2f5; /* Light background */
            color: #333; /* Dark text */
        }
        .light .bg-white {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .light h1, .light h2, .light label {
            color: #222;
        }
        .light p {
            color: #555;
        }
        .light .border-gray-200 {
            border-color: #e0e0e0;
        }
        .light .border-gray-300 {
            border-color: #ccc;
        }

        .light .file-input-wrapper label {
            background-color: #3b82f6; /* Standard blue for light mode */
            color: white;
        }
        .light .file-input-wrapper label:hover {
            background-color: #2563eb;
        }

        .light .drop-zone {
            background-color: #ffffff;
            border-color: #ccc;
        }
        .light .drop-zone.drag-over {
            border-color: #3b82f6 !important;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .light .drop-zone p {
            color: #666;
        }
        .light .drop-zone span {
            color: #666;
        }

        /* Common styles for buttons and elements */
        button {
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: 600; /* font-semibold */
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        button:disabled {
            background-color: #4a5568 !important; /* bg-gray-600 for dark, gray-300 for light */
            cursor: not-allowed;
            box-shadow: none;
        }
        .dark button:disabled {
            background-color: #333a42 !important;
            color: #8b949e;
        }
        .light button:disabled {
            background-color: #cbd5e0 !important;
            color: #718096;
        }

        /* Specific button styles */
        .primary-button {
            background-color: #007bff; /* A vibrant blue */
            color: white;
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3);
        }
        .primary-button:not(:disabled):hover {
            background-color: #0056b3;
            box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4);
        }

        .success-button {
            background-color: #28a745; /* A vibrant green */
            color: white;
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }
        .success-button:not(:disabled):hover {
            background-color: #1e7e34;
            box-shadow: 0 6px 12px rgba(40, 167, 69, 0.4);
        }

        /* RS Projects specific styling */
        #rs-projects-text {
            font-family: 'Rajdhani', sans-serif; /* Futuristic font */
            font-size: 1.5rem; /* Larger font size */
            font-weight: 700;
            letter-spacing: 0.1em; /* Increased letter spacing */
            margin-top: -5px; /* Adjust vertical alignment with logo */
        }
        .dark #rs-projects-text {
            color: #00d4ff; /* Bright cyan for dark mode */
            text-shadow: 0 0 8px rgba(0, 212, 255, 0.6); /* Subtle glow */
        }
        .light #rs-projects-text {
            color: #007bff; /* Consistent blue for light mode */
            text-shadow: none;
        }

        /* Theme toggle switch styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-left: auto; /* Push to the right */
            margin-top: -10px; /* Adjust vertical position */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-4xl">
        <div class="flex flex-col md:flex-row items-center justify-center mb-6 relative">
            <div class="flex items-center justify-center md:mr-auto mb-4 md:mb-0">
                <!-- Logo image -->
                <img src="https://yt3.ggpht.com/ngn-9Dc6-sRhEOjNglyYu3M_xcXEjm8a569VvH8ZxHHQ1gjZ_KacvIXPyz41zkYLAtVxNIR4pyA=s600-c-k-c0x00ffffff-no-rj-rp-mo"
                     alt="Logo"
                     class="w-16 h-16 rounded-full mr-4 object-cover"
                     onerror="this.onerror=null;this.src='https://placehold.co/64x64/cccccc/333333?text=Logo';"
                >
                <div class="flex flex-col items-center md:items-start">
                    <h1 class="text-3xl font-bold text-center md:text-left text-gray-800">
                        Sortowanie dwustronnych PDF
                    </h1>
                    <span id="rs-projects-text" class="text-gray-700 mt-1">RS PROJECTS</span>
                </div>
            </div>

            <!-- Theme Toggle Switch -->
            <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider round"></span>
            </label>
        </div>

        <p class="text-gray-600 text-center mb-6">
            Wybierz jedną z poniższych metod sortowania. Możesz także przeciągać i upuszczać pliki.
        </p>

        <div class="flex flex-col md:flex-row gap-6">
            <!-- Sekcja sortowania dwóch plików PDF (Metoda A) -->
            <div class="border border-gray-200 rounded-xl p-6 flex-1">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Metoda A: Dwa pliki PDF</h2>
                <p class="text-gray-600 text-sm mb-4">
                    Wgraj dwa pliki: jeden ze stronami nieparzystymi (po kolei) i drugi ze stronami parzystymi (od tyłu).
                </p>

                <div class="mb-4 file-input-wrapper">
                    <label for="pdf1" class="block text-gray-700 text-sm font-semibold mb-2">
                        Plik PDF 1 (strony nieparzyste, po kolei):
                    </label>
                    <div id="dropZonePdf1" class="drop-zone border-2 border-dashed border-gray-300 rounded-lg p-4 text-center cursor-pointer hover:border-blue-500 transition-colors duration-200">
                        <p class="text-gray-500 mb-2">Przeciągnij i upuść plik PDF tutaj</p>
                        <input
                            type="file"
                            id="pdf1"
                            accept=".pdf"
                            class="hidden"
                        />
                        <label for="pdf1" class="inline-block bg-blue-500 text-white py-2 px-4 rounded-lg cursor-pointer hover:bg-blue-600 transition-colors duration-200">
                            Wybierz plik
                        </label>
                        <span id="fileNamePdf1" class="block text-sm text-gray-600 mt-2"></span>
                    </div>
                </div>

                <div class="mb-6 file-input-wrapper">
                    <label for="pdf2" class="block text-gray-700 text-sm font-semibold mb-2">
                        Plik PDF 2 (strony parzyste, od tyłu):
                    </label>
                    <div id="dropZonePdf2" class="drop-zone border-2 border-dashed border-gray-300 rounded-lg p-4 text-center cursor-pointer hover:border-blue-500 transition-colors duration-200">
                        <p class="text-gray-500 mb-2">Przeciągnij i upuść plik PDF tutaj</p>
                        <input
                            type="file"
                            id="pdf2"
                            accept=".pdf"
                            class="hidden"
                        />
                        <label for="pdf2" class="inline-block bg-blue-500 text-white py-2 px-4 rounded-lg cursor-pointer hover:bg-blue-600 transition-colors duration-200">
                            Wybierz plik
                        </label>
                        <span id="fileNamePdf2" class="block text-sm text-gray-600 mt-2"></span>
                    </div>
                </div>

                <button
                    id="sortTwoFilesButton"
                    disabled
                    class="w-full py-3 px-4 primary-button"
                >
                    Sortuj dwa pliki PDF
                </button>
            </div>

            <!-- Sekcja sortowania jednego pliku PDF (Metoda B) -->
            <div class="border border-gray-200 rounded-xl p-6 flex-1">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Metoda B: Jeden plik PDF</h2>
                <p class="text-gray-600 text-sm mb-4">
                    Wgraj jeden plik PDF, który zawiera strony nieparzyste (po kolei), a następnie strony parzyste (od tyłu).
                </p>

                <div class="mb-6 file-input-wrapper">
                    <label for="singlePdf" class="block text-gray-700 text-sm font-semibold mb-2">
                        Jeden plik PDF (scalony i do posortowania):
                    </label>
                    <div id="dropZoneSinglePdf" class="drop-zone border-2 border-dashed border-gray-300 rounded-lg p-4 text-center cursor-pointer hover:border-blue-500 transition-colors duration-200">
                        <p class="text-gray-500 mb-2">Przeciągnij i upuść plik PDF tutaj</p>
                        <input
                            type="file"
                            id="singlePdf"
                            accept=".pdf"
                            class="hidden"
                        />
                        <label for="singlePdf" class="inline-block bg-blue-500 text-white py-2 px-4 rounded-lg cursor-pointer hover:bg-blue-600 transition-colors duration-200">
                            Wybierz plik
                        </label>
                        <span id="fileNameSinglePdf" class="block text-sm text-gray-600 mt-2"></span>
                    </div>
                </div>

                <button
                    id="sortSingleFileButton"
                    disabled
                    class="w-full py-3 px-4 primary-button"
                >
                    Sortuj jeden plik PDF
                </button>
            </div>
        </div>

        <!-- Obszar wiadomości i pobierania (wspólny dla obu metod) -->
        <p id="errorMessage" class="mt-4 text-red-600 text-sm text-center hidden"></p>
        <p id="successMessage" class="mt-4 text-green-600 text-sm text-center hidden"></p>

        <div id="downloadArea" class="mt-6 text-center hidden">
            <a
                id="downloadLink"
                download="posortowany_dokument.pdf"
                class="inline-block py-3 px-6 rounded-lg shadow-md transition-colors duration-200 success-button"
            >
                Pobierz posortowany PDF
            </a>
        </div>
    </div>

    <script>
        // Get references to DOM elements for Method A (Two files)
        const pdf1Input = document.getElementById('pdf1');
        const pdf2Input = document.getElementById('pdf2');
        const sortTwoFilesButton = document.getElementById('sortTwoFilesButton');
        const dropZonePdf1 = document.getElementById('dropZonePdf1');
        const dropZonePdf2 = document.getElementById('dropZonePdf2');
        const fileNamePdf1 = document.getElementById('fileNamePdf1');
        const fileNamePdf2 = document.getElementById('fileNamePdf2');


        // Get references to DOM elements for Method B (Single file)
        const singlePdfInput = document.getElementById('singlePdf');
        const sortSingleFileButton = document.getElementById('sortSingleFileButton');
        const dropZoneSinglePdf = document.getElementById('dropZoneSinglePdf');
        const fileNameSinglePdf = document.getElementById('fileNameSinglePdf');


        // Get references to common UI elements
        const errorMessageElem = document.getElementById('errorMessage');
        const successMessageElem = document.getElementById('successMessage');
        const downloadArea = document.getElementById('downloadArea');
        const downloadLink = document.getElementById('downloadLink');
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;


        let pdf1File = null;
        let pdf2File = null;
        let singlePdfFile = null;

        /**
         * Updates button states based on file selection.
         * Resets button text and applies/removes Tailwind classes for styling.
         * This function no longer hides success/error messages or download area.
         */
        function updateButtonStates() {
            // Update state for Method A button
            if (pdf1File && pdf2File) {
                sortTwoFilesButton.disabled = false;
                sortTwoFilesButton.classList.remove('bg-blue-300', 'cursor-not-allowed');
                sortTwoFilesButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-md');
            } else {
                sortTwoFilesButton.disabled = true;
                sortTwoFilesButton.classList.add('bg-blue-300', 'cursor-not-allowed');
                sortTwoFilesButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'shadow-md');
            }
            sortTwoFilesButton.textContent = 'Sortuj dwa pliki PDF'; // Reset text
            fileNamePdf1.textContent = pdf1File ? pdf1File.name : '';
            fileNamePdf2.textContent = pdf2File ? pdf2File.name : '';


            // Update state for Method B button
            if (singlePdfFile) {
                sortSingleFileButton.disabled = false;
                sortSingleFileButton.classList.remove('bg-blue-300', 'cursor-not-allowed');
                sortSingleFileButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-md');
            } else {
                sortSingleFileButton.disabled = true;
                sortSingleFileButton.classList.add('bg-blue-300', 'cursor-not-allowed');
                sortSingleFileButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'shadow-md');
            }
            sortSingleFileButton.textContent = 'Sortuj jeden plik PDF'; // Reset text
            fileNameSinglePdf.textContent = singlePdfFile ? singlePdfFile.name : '';
        }

        /**
         * Clears all messages and download link. This should be called when new files are selected
         * or at the start of a new processing attempt.
         */
        function clearMessagesAndDownloadLink() {
            errorMessageElem.classList.add('hidden');
            successMessageElem.classList.add('hidden');
            downloadArea.classList.add('hidden');
            downloadLink.href = '#'; // Clear previous download link
        }

        /**
         * Resets the inputs and files for Method A.
         */
        function resetMethodAInputs() {
            pdf1Input.value = '';
            pdf2Input.value = '';
            pdf1File = null;
            pdf2File = null;
        }

        /**
         * Resets the input and file for Method B.
         */
        function resetMethodBInputs() {
            singlePdfInput.value = '';
            singlePdfFile = null;
        }

        // Event listeners for file inputs (Method A)
        pdf1Input.addEventListener('change', (event) => {
            pdf1File = event.target.files[0];
            resetMethodBInputs(); // Clear Method B inputs if Method A file is selected
            clearMessagesAndDownloadLink(); // Clear messages on new file selection
            updateButtonStates();
        });

        pdf2Input.addEventListener('change', (event) => {
            pdf2File = event.target.files[0];
            resetMethodBInputs(); // Clear Method B inputs if Method A file is selected
            clearMessagesAndDownloadLink(); // Clear messages on new file selection
            updateButtonStates();
        });

        // Event listener for file input (Method B)
        singlePdfInput.addEventListener('change', (event) => {
            singlePdfFile = event.target.files[0];
            resetMethodAInputs(); // Clear Method A inputs if Method B file is selected
            clearMessagesAndDownloadLink(); // Clear messages on new file selection
            updateButtonStates();
        });

        /**
         * Generic drag event handlers for drop zones.
         * @param {Event} event - The drag event.
         */
        function handleDragOver(event) {
            event.preventDefault(); // Prevent default to allow drop
            event.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        /**
         * Handles the drop event for Method A, PDF 1.
         * @param {Event} event - The drop event.
         */
        dropZonePdf1.addEventListener('dragover', handleDragOver);
        dropZonePdf1.addEventListener('dragleave', handleDragLeave);
        dropZonePdf1.addEventListener('drop', (event) => {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                pdf1Input.files = files; // Assign files to the hidden input
                pdf1File = files[0];
                resetMethodBInputs();
                clearMessagesAndDownloadLink(); // Clear messages on new file selection
                updateButtonStates();
            } else {
                errorMessageElem.textContent = 'Proszę upuścić plik PDF.';
                errorMessageElem.classList.remove('hidden');
            }
        });

        /**
         * Handles the drop event for Method A, PDF 2.
         * @param {Event} event - The drop event.
         */
        dropZonePdf2.addEventListener('dragover', handleDragOver);
        dropZonePdf2.addEventListener('dragleave', handleDragLeave);
        dropZonePdf2.addEventListener('drop', (event) => {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                pdf2Input.files = files; // Assign files to the hidden input
                pdf2File = files[0];
                resetMethodBInputs();
                clearMessagesAndDownloadLink(); // Clear messages on new file selection
                updateButtonStates();
            } else {
                errorMessageElem.textContent = 'Proszę upuścić plik PDF.';
                errorMessageElem.classList.remove('hidden');
            }
        });

        /**
         * Handles the drop event for Method B, Single PDF.
         * @param {Event} event - The drop event.
         */
        dropZoneSinglePdf.addEventListener('dragover', handleDragOver);
        dropZoneSinglePdf.addEventListener('dragleave', handleDragLeave);
        dropZoneSinglePdf.addEventListener('drop', (event) => {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                singlePdfInput.files = files; // Assign files to the hidden input
                singlePdfFile = files[0];
                resetMethodAInputs();
                clearMessagesAndDownloadLink(); // Clear messages on new file selection
                updateButtonStates();
            } else {
                errorMessageElem.textContent = 'Proszę upuścić plik PDF.';
                errorMessageElem.classList.remove('hidden');
            }
        });

        /**
         * Processes two PDF files (odd pages and reversed even pages) and interleaves them.
         */
        sortTwoFilesButton.addEventListener('click', async () => {
            sortTwoFilesButton.textContent = 'Przetwarzanie...';
            sortTwoFilesButton.disabled = true; // Disable button immediately
            clearMessagesAndDownloadLink(); // Clear previous messages at start of processing

            try {
                if (!pdf1File || !pdf2File) {
                    errorMessageElem.textContent = 'Proszę wgrać oba pliki PDF dla Metody A.';
                    errorMessageElem.classList.remove('hidden');
                    return;
                }

                const pdf1Bytes = await pdf1File.arrayBuffer();
                const pdf2Bytes = await pdf2File.arrayBuffer();

                const pdf1Doc = await PDFLib.PDFDocument.load(pdf1Bytes);
                const pdf2Doc = await PDFLib.PDFDocument.load(pdf2Bytes);

                const numPages1 = pdf1Doc.getPages().length;
                const numPages2 = pdf2Doc.getPages().length;

                if (numPages1 !== numPages2) {
                    errorMessageElem.textContent = `Liczba stron w plikach PDF Metody A jest różna. Plik 1 ma ${numPages1} stron, a Plik 2 ma ${numPages2} stron. Proszę upewnić się, że każdy plik zawiera po tyle samo stron.`;
                    errorMessageElem.classList.remove('hidden');
                    return;
                }

                const newPdfDoc = await PDFLib.PDFDocument.create();

                for (let i = 0; i < numPages1; i++) {
                    const [oddPage] = await newPdfDoc.copyPages(pdf1Doc, [i]);
                    newPdfDoc.addPage(oddPage);

                    const evenPageIndexInPdf2 = numPages2 - 1 - i;
                    const [evenPage] = await newPdfDoc.copyPages(pdf2Doc, [evenPageIndexInPdf2]);
                    newPdfDoc.addPage(evenPage);
                }

                const pdfBytes = await newPdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                downloadLink.href = url;
                downloadArea.classList.remove('hidden');
                successMessageElem.textContent = 'Plik PDF został pomyślnie posortowany Metodą A!';
                successMessageElem.classList.remove('hidden');

            } catch (error) {
                console.error('Błąd podczas przetwarzania PDF (Metoda A):', error);
                errorMessageElem.textContent = 'Wystąpił błąd podczas przetwarzania plików PDF Metodą A. Upewnij się, że są to prawidłowe pliki PDF.';
                errorMessageElem.classList.remove('hidden');
            } finally {
                updateButtonStates(); // Reset button text and state (only button, not messages/download link)
            }
        });

        /**
         * Processes a single PDF file (odd pages then reversed even pages) and sorts it.
         */
        sortSingleFileButton.addEventListener('click', async () => {
            sortSingleFileButton.textContent = 'Przetwarzanie...';
            sortSingleFileButton.disabled = true; // Disable button immediately
            clearMessagesAndDownloadLink(); // Clear previous messages at start of processing

            try {
                if (!singlePdfFile) {
                    errorMessageElem.textContent = 'Proszę wgrać jeden plik PDF dla Metody B.';
                    errorMessageElem.classList.remove('hidden');
                    return;
                }

                const pdfBytes = await singlePdfFile.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);

                const totalPages = pdfDoc.getPages().length;

                // Validate that the total number of pages is even for duplex sorting
                if (totalPages % 2 !== 0) {
                    errorMessageElem.textContent = `Wgrany plik PDF Metody B musi zawierać parzystą liczbę stron (ma ${totalPages} stron).`;
                    errorMessageElem.classList.remove('hidden');
                    return;
                }

                const halfPages = totalPages / 2;
                const newPdfDoc = await PDFLib.PDFDocument.create();

                // Logic: first half pages are odd (1, 3, 5...), second half pages are even (26, 24, 22...) in reverse
                // Example: 26 pages total, halfPages = 13
                // Odd pages are at index 0 to 12
                // Even pages are at index 13 to 25 (where index 13 is page 26, index 25 is page 2)
                for (let i = 0; i < halfPages; i++) {
                    // Add the odd page (from the first half of the original PDF)
                    const [oddPage] = await newPdfDoc.copyPages(pdfDoc, [i]);
                    newPdfDoc.addPage(oddPage);

                    // Add the even page (from the second half of the original PDF, in reverse order)
                    // The index for the even page from the original PDF is:
                    // (start of even pages block) + (number of pages from end of even block)
                    // halfPages + (halfPages - 1 - i)
                    // For i=0, we need the last page of the original PDF: halfPages + halfPages - 1 = totalPages - 1
                    // For i=1, we need the second to last: halfPages + halfPages - 2 = totalPages - 2
                    // This simplifies to totalPages - 1 - i for the even page index.
                    const evenPageIndexInOriginalPdf = totalPages - 1 - i;
                    const [evenPage] = await newPdfDoc.copyPages(pdfDoc, [evenPageIndexInOriginalPdf]);
                    newPdfDoc.addPage(evenPage);
                }

                const sortedPdfBytes = await newPdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                downloadLink.href = url;
                downloadArea.classList.remove('hidden');
                successMessageElem.textContent = 'Plik PDF został pomyślnie posortowany Metodą B!';
                successMessageElem.classList.remove('hidden');

            } catch (error) {
                console.error('Błąd podczas przetwarzania PDF (Metoda B):', error);
                errorMessageElem.textContent = 'Wystąpił błąd podczas przetwarzania pliku PDF Metodą B. Upewnij się, że to prawidłowy plik PDF o parzystej liczbie stron.';
                errorMessageElem.classList.remove('hidden');
            } finally {
                updateButtonStates(); // Reset button text and state (only button, not messages/download link)
            }
        });

        // Theme toggle logic
        themeToggle.addEventListener('change', () => {
            if (themeToggle.checked) {
                body.classList.remove('dark');
                body.classList.add('light');
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.remove('light');
                body.classList.add('dark');
                localStorage.setItem('theme', 'dark');
            }
        });

        // Set initial theme based on localStorage or default to dark
        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                body.classList.remove('dark');
                body.classList.add('light');
                themeToggle.checked = true;
            } else {
                body.classList.remove('light');
                body.classList.add('dark');
                themeToggle.checked = false;
            }
        }

        // Initialize button state and theme on page load
        updateButtonStates();
        setInitialTheme();
    </script>
</body>
</html>
